Package goplusplus;

/*==========================*/
/*			Helpers			*/
/*==========================*/
Helpers
	all 		= [0 .. 0xFF];
	tab   		= 9;
	cr    		= 13;
	lf    		= 10;
	newline		= cr | lf | cr lf;
	dec_digit 	= ['0'..'9'];
	oct_digit	= ['0'..'7'];
	hex_digit	= ['0'..'9'] | ['A'..'F'] | ['a'..'f'];
	lowercase 	= ['a'..'z'];
	uppercase 	= ['A'..'Z'];
	letter  	= lowercase | uppercase;
	idletter 	= letter | '_';
	idchar  	= letter | '_' | dec_digit;
	printable 	= [0x20 .. 0xFF];
	char 		= printable | tab;
	comment_lin = '//';
	comment_beg = '/*';
	comment_end = '*/';
	dec 		= ['1'..'9'] (dec_digit)*;
	oct			= '0' (oct_digit)*;
	hex			= '0' ('x' | 'X') (hex_digit)+;


/*==========================*/
/*			Tokens			*/
/*==========================*/
Tokens
	eol			= newline;
	blank 		= ' ' | tab;

/*Keywords*/
	break		= 'break';
	default		= 'default';
	func		= 'func';
	interface	= 'interface';
	select		= 'select';
	case		= 'case';
	defer		= 'defer';
	go 			= 'go';
	map			= 'map';
	struct		= 'struct';
	chan		= 'chan';
	else		= 'else';
	goto		= 'goto';
	package		= 'package';
	switch		= 'switch';
	const		= 'const';
	fallthrough	= 'fallthrough';
	if			= 'if';
	range		= 'range';
	type		= 'type';
	continue	= 'continue';
	for			= 'for';
	import		= 'import';
	return		= 'return';
	var			= 'var';
	basic_types	= 'int' | 'float64' | 'bool' | 'rune' | 'string';
	print		= 'print';
	println		= 'println';
	append		= 'append';

/*Operators*/
	add			= '+';
	sub			= '-';
	mul			= '*';
	div			= '/';
	mod			= '%';
	bit_and		= '&';
	bit_or		= '|';
	caret		= '^';
	lshift		= '<<';
	rshift		= '>>';
	bitclear	= '&^';
	pluseq		= '+=';
	subeq		= '-=';
	muleq		= '*=';
	diveq		= '/=';
	modeq		= '%=';
	andeq		= '&=';
	oreq		= '|=';
	xoreq		= '^=';
	lshifteq	= '<<=';
	rshifteq	= '>>=';
	bitcleareq	= '&^=';
	and			= '&&';
	or			= '||';
	receive		= '<-';
	increment	= '++';
	decrement	= '--';
	eq			= '==';
	lt			= '<';
	gt			= '>';
	assign		= '=';
	not			= '!';
	noteq		= '!=';
	leq			= '<=';
	geq			= '>=';
	shortdecl	= ':=';
	varargs		= '...';
	leftpar		= '(';
	leftsq		= '[';
	leftcurl	= '{';
	comma		= ',';
	dot 		= '.';
	rightpar	= ')';
	rightsq		= ']';
	rightcurl	= '}';
	semicolon	= ';';
	colon		= ':';
	
/*Comment*/
	line_comment 		= comment_lin all* newline;
	block_comment	 	= comment_beg all* comment_end;

/*Literals*/
	escaped_char 		= '\' ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\' | ''' | '"');
	int_lit				= dec | oct | hex;
	float_lit 			= ((dec_digit)* '.' (dec_digit)+) | ((dec_digit)+ '.' (dec_digit)*);
	raw_string 			= ''' (char | newline)* ''';
	interpreted_string 	= '"' (char | newline)* '"';

/*Identifiers*/
	id = idletter idchar*;


Ignored Tokens
	blank, eol, line_comment, block_comment;


/*==========================*/
/*		Productions			*/
/*==========================*/
Productions
	program {-> program} =
		package id semi decl*
			{-> New program(id, [decl])}
	;

	decl {-> declaration} =
		var var_decl semi
			{-> New declaration.var_dec([var_decl.var_declaration])}
	|	type type_decl semi
			{-> New declaration.type_dec([type_decl.type_declaration])}
	|	func func_decl semi
	;

	id_list {-> id*} =
		 id id_tail*
		 	{-> [id, id_tail.id]}
	;

	id_tail {-> id} =
		comma id
			{-> id}
	;

	exp_list {-> ast_exp*} =
		prod_exp exp_tail*
			{-> [prod_exp, exp_tail.ast_exp]}
	;

	exp_tail {-> ast_exp} =
		comma prod_exp
			{-> ast_exp}
	;

	/*======================*/
	/*		Declaration		*/
	/*======================*/

	var_decl {-> var_declaration} = 
		{single}	var_decl_single
			{-> var_decl_sinle.var_declaration}
	|	{list}		leftpar var_decl_single_semi* rightpar
			{-> var_decl_single_semi.var_declaration}
	;

	var_decl_single {-> var_declaration} = 
		{type}		id_list prod_type_exp
			{-> New var_declaration.var_dec_typeOnly([id_list.id], prod_type_exp.ast_type_exp)}
	|	{expr}		id_list assign exp_list
			{-> New var_declaration.var_dec_expOnly([id_list.id], [exp_list.exp] )}
	|	{type_exp}	id_list prod_type_exp assign exp_list
			{-> New var_declaration.var_dec_typeExp([id_list.id], prod_type_exp.ast_type_exp, [exp_list.exp])}
	;

	var_decl_single_semi {-> var_declaration} =
		var_decl_single semi
			{-> var_decl_single.var_declaration}
	;

	type_decl =
		{single}	type_decl_single
	|	{list}		leftpar type_decl_single_semi* rightpar
	;

	type_decl_single =
		id prod_type_exp
	;

	type_decl_single_semi =
		type_decl_single semi
	;

	prod_type_exp {-> ast_type_exp} =
		{basic}		basic_types
	|	{slice}		leftsq rightsq prod_type_exp
	|	{array}		leftsq int_lit rightsq prod_type_exp
	|	{struct}	struct leftcurl struct_decl* rightcurl
	;

	struct_decl =
		id_list prod_type_exp semi
	;

	func_decl =
		id leftpar func_param? rightpar prod_type_exp? block
	;

	func_param = 
		id_list prod_type_exp func_param_tail*
	;

	func_param_tail =
		comma func_param
	;

	block =
		leftcurl rightcurl
	;

/*==========================*/
/*			AST				*/
/*==========================*/
Abstract Syntax Tree
	program = 
		[package]:id [decl]:declaration*
	;
	
	declaration = 
	|	{var_dec}			var_declaration
	|	{type_dec} 			type_declaration
	|	{func_dec}			id (id+ ast_type_exp)* ast_type_exp? ast_stm
	;
	
	var_declaration = 
		{var_dec_typeOnly} 	id+ ast_type_exp
	|	{var_dec_expOnly} 	id+ ast_exp+
	|	{var_dec_typeExp} 	id+ ast_type_exp ast_exp+
	;

	type_declaration = 
		id+ ast_type_exp+
	|
	
	ast_type_exp = 
		{basic}		basic_types
	|	{slice}		ast_type_exp
	|	{array}		[size]int_lit ast_type_exp
	|	{struct}	strct_field*
	|	{alias}		id
	;

	strct_field = id+ ast_type_exp;
	
	ast_stm =
		{empty}
	|	{exp}			ast_exp
	|	{assign}		[lval]:ast_exp+ [rval]ast_exp+
	|	{op_assign}		[l]:ast_exp binary_op [r]:ast_exp
	|	{var_decl}		var_declaration+
	|	{short_decl}	[ids] ast_exp+ ast_exp+
	|	{type_decl}		type_decl+
	|	{inc_dec}		ast_exp post_op ast_exp
	|	{print}			ast_exp*
	|	{println}		ast_exp*
	|	{return}		ast_exp?
	|	{shortif}		[init] ast_stm? [condition]:ast_exp ast_stm*
	|	{longif}		[init] ast_stm? [condition]:ast_exp [if_stms]ast_stm* elseif* [else_stms]:ast_stm*
	|	{switch}		ast_stm? ast_exp? switch_case+
	|	{for}			[init] ast_stm? [condition] ast_exp? [post] ast_stm? [body] ast_stm*
	|	{break}
	|	{continue}
	;
	
	ast_exp = 
		{parenthesized}	ast_exp
	|	{identifier}	id
	|	{literal}		literal
	|	{unary_op}		unary_op ast_exp
	|	{binary_op}		[left]:ast_exp binary_op [right]:ast_exp
	|	{func_call}		[name]:ast_exp [args]:ast_exp*
	|	{apppend}		id ast_exp
	|	{cast}			ast_type_exp ast_exp
	|	{array_access}	[array]:ast_exp [index]:ast_exp
	|	{field_access}	[struct]:ast_exp [field]:id
	;

	elseif = [condition]:ast_exp ast_stm*;
	
	switch_case = 
		{default}		ast_stm*
	|	{case} 			ast_exp+ ast_stm*
	;
	
	literal = 
		{intval} 	int_lit
	|	{floatval} 	float_lit
	|	{boolval} 	bool_lit
	|	{runeval} 	rune_lit
	|	{stringval} string_lit
	;

	binary_op = 
		{add}
	|	{sub}
	|	{mul}
	|	{div}
	|	{mod}
	|	{bitor}
	|	{bitand}
	|	{bitxor}
	|	{lshift}
	|	{rshift}
	|	{bitclear}
	;
	
	unary_op = {plus} | {minus} | {not} | {caret};
	
	post_op = 
		{inc}
	|	{dec}
	;